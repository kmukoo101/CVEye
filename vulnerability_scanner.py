"""
Vulnerability Scanner Script (Ultimate Edition)

Features:
- Scans all privileged TCP and UDP ports
- Grabs service banners and detects outdated services
- Matches banners to known CVEs using flexible regex patterns
- Supports full credential brute-force attempts for FTP and MySQL
- Saves results to log and JSON for automation
- Allows toggling UDP scan and port range
- Shows a summary and scan duration at the end

Cross-platform: Compatible with macOS, Windows, and Linux (Python 3.6+)
Dependencies (optional): ftplib (built-in), pymysql (install via pip)

"""

import socket
import threading
import time
import os
import logging
from datetime import datetime
import json
import re
import argparse

try:
    import ftplib  # For FTP brute-force
except ImportError:
    ftplib = None

try:
    import pymysql  # For MySQL brute-force
except ImportError:
    pymysql = None

# Load CVE hints from JSON file (regex pattern → CVE)
CVE_HINTS_FILE = "cve_hints.json"
CVE_HINTS = {}
if os.path.exists(CVE_HINTS_FILE):
    with open(CVE_HINTS_FILE, 'r') as f:
        CVE_HINTS = json.load(f)

# Configure logging to file
TIMESTAMP = datetime.now().strftime('%Y%m%d_%H%M%S')
RESULTS_LOG_FILE = f"scan_results_{TIMESTAMP}.log"
RESULTS_JSON_FILE = f"scan_results_{TIMESTAMP}.json"
logging.basicConfig(
    filename=RESULTS_LOG_FILE,
    filemode='w',
    format='%(asctime)s [%(levelname)s] %(message)s',
    level=logging.INFO
)

# Dictionary of weak/default credentials for services
CREDENTIAL_DICTIONARY = {
    "ftp": ["admin:admin", "root:root", "user:1234", "ftp:ftp", "test:test"],
    "mysql": ["root:", "admin:admin", "user:password"]
}

# Shared scan result container and lock for thread safety
lock = threading.Lock()
scan_results = {"open_ports": [], "credentials": [], "cves": []}

def log_result(message: str, level=logging.INFO):
    """Prints and logs a message with optional logging level."""
    with lock:
        print(message)
        logging.log(level, message)

def detect_cves(banner: str):
    """Matches banner strings to known CVEs using regex loaded from a JSON file."""
    for pattern, cve in CVE_HINTS.items():
        if re.search(pattern, banner, re.IGNORECASE):
            log_result(f"    [CVE Detected] Match: '{pattern}' → {cve}", logging.WARNING)
            scan_results["cves"].append({"pattern": pattern, "cve": cve, "banner": banner})

def brute_force(host: str, port: int, service: str):
    """Attempts default credential login for specified service."""
    log_result(f"    [*] Attempting brute-force on {service.upper()} at {host}:{port}")
    credentials = CREDENTIAL_DICTIONARY.get(service, [])

    if service == "ftp" and ftplib:
        for entry in credentials:
            user, pwd = entry.split(":", 1)
            try:
                with ftplib.FTP() as ftp:
                    ftp.connect(host, port, timeout=2)
                    ftp.login(user=user, passwd=pwd)
                    log_result(f"    [!] Successful FTP login: {user}/{pwd}", logging.WARNING)
                    scan_results["credentials"].append({"service": service, "username": user, "password": pwd})
                    return
            except Exception:
                continue

    elif service == "mysql" and pymysql:
        for entry in credentials:
            user, pwd = entry.split(":", 1)
            try:
                conn = pymysql.connect(host=host, port=port, user=user, password=pwd, connect_timeout=2)
                log_result(f"    [!] Successful MySQL login: {user}/{pwd}", logging.WARNING)
                scan_results["credentials"].append({"service": service, "username": user, "password": pwd})
                conn.close()
                return
            except Exception:
                continue

    else:
        log_result(f"    [-] Brute-force not supported or required module missing for {service}.")

def scan_tcp_port(host: str, port: int):
    """Performs a TCP scan on the specified port and attempts banner grabbing and brute-force."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            if result == 0:
                log_result(f"[+] TCP Port {port} is open.")
                scan_results["open_ports"].append({"port": port, "protocol": "TCP"})
                try:
                    sock.send(b'\n')
                    banner = sock.recv(1024).decode(errors='ignore').strip()
                    if banner:
                        log_result(f"    Banner: {banner}")
                        if "old" in banner.lower() or "deprecated" in banner.lower():
                            log_result("    [!] Potentially outdated service detected.", logging.WARNING)
                        detect_cves(banner)
                        for keyword in CREDENTIAL_DICTIONARY:
                            if keyword in banner.lower():
                                brute_force(host, port, keyword)
                except Exception:
                    pass
    except Exception as e:
        log_result(f"[-] TCP Scan Error on port {port}: {e}", logging.ERROR)

def scan_udp_port(host: str, port: int):
    """Sends a basic UDP probe and logs any response (best effort)."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
            sock.settimeout(2)
            sock.sendto(b'\x00', (host, port))
            data, _ = sock.recvfrom(1024)
            log_result(f"[+] UDP Port {port} responded.")
            scan_results["open_ports"].append({"port": port, "protocol": "UDP"})
    except socket.timeout:
        pass
    except Exception as e:
        log_result(f"[-] UDP Scan Error on port {port}: {e}", logging.ERROR)

def run_scan(target: str, port_range: range, enable_udp: bool):
    """Runs the full scan with threading and saves results to file."""
    start_time = time.time()
    log_result(f"Starting scan on host: {target}\n")
    threads = []

    for port in port_range:
        tcp_thread = threading.Thread(target=scan_tcp_port, args=(target, port))
        threads.append(tcp_thread)
        tcp_thread.start()

        if enable_udp:
            udp_thread = threading.Thread(target=scan_udp_port, args=(target, port))
            threads.append(udp_thread)
            udp_thread.start()

    for thread in threads:
        thread.join()

    duration = time.time() - start_time
    log_result(f"\nScan complete in {duration:.2f} seconds.")
    log_result(f"Results saved to {RESULTS_LOG_FILE} and {RESULTS_JSON_FILE}")

    with open(RESULTS_JSON_FILE, 'w') as f:
        json.dump(scan_results, f, indent=2)

    # Summary
    log_result(f"\nSummary:")
    log_result(f"  Open Ports: {len(scan_results['open_ports'])}")
    log_result(f"  Credentials Found: {len(scan_results['credentials'])}")
    log_result(f"  CVEs Detected: {len(scan_results['cves'])}")

def main():
    """Parses CLI arguments and starts the scan."""
    parser = argparse.ArgumentParser(description="Advanced Vulnerability Scanner")
    parser.add_argument("target", help="Target IP address")
    parser.add_argument("--start-port", type=int, default=1, help="Start of port range (default: 1)")
    parser.add_argument("--end-port", type=int, default=1024, help="End of port range (default: 1024)")
    parser.add_argument("--no-udp", action="store_true", help="Disable UDP scanning")
    args = parser.parse_args()

    try:
        socket.inet_aton(args.target)
    except socket.error:
        print("Invalid IP address.")
        return

    port_range = range(args.start_port, args.end_port + 1)
    run_scan(args.target, port_range, not args.no_udp)

if __name__ == "__main__":
    main()
